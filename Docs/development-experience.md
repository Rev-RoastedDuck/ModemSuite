# 协议
## XMODEM
- 流程
  - 接收端发启动请求：**NAK（请求 checksum）或 'C' (0x43， 请求 CRC16)**。
  - 发送端收到启动字符后发送**数据包**（按序号、含校验）。
  - 接收端验证包头/包号/反码/长度/**校验**：成功 -> ACK；失败 -> NAK（要求重传）。
  - 发送端重试若干次超限则发送 **CAN 终止**。
  - **发送端全部数据发送完后发 EOT；接收端 ACK 完成会话**。

- 包结构
  - **Header**: SOH(0x01) 表示 128B；STX(0x02) 表示 1K（部分 XMODEM 实现仅支持 SOH）。
  - **Block#** (1 byte)、**Block# 的按位取反** (1 byte)。
  - **Data**: 固定长度（128 或 1024），**不足处填充（常用 0x1A 或 0x00）**。
  - **校验**: checksum (1 byte) 或 CRC16 (2 bytes，先高字节后低字节)。

- 关键细节
  - 包号从 1 开始，模 256 回绕；重复包应 ACK 并丢弃数据以避免重复写入。
  - CRC 请求由接收端通过发送 'C' 发起（更可靠）；NAK 表示使用简单 checksum。
  - 超时与重传策略要明确：启动重试、单包重传计数、全局取消阈值。
  - 粘包/半包处理：接收端需缓冲流并搜索完整包头与长度后再解析。
  - 校验实现：**CRC16 用多项式 0x1021**（常见）；校验字节序是高字节先发。
  - 取消：CAN（0x18）用于立即中止会话。

## YMODEM
- 流程
  - 接收端发启动请求：**NAK（请求 checksum）或 'C' (0x43， 请求 CRC16)**。
  - **第0包（文件信息包）由发送端发送：包含文件名（NUL 结束）和文件大小等元数据**；接收端 ACK（并通常再次发送 'C'）以准备接收正式数据包。
  - 发送端按序发送**数据包**（通常使用 1K 包以提高效率），每包接收端 ACK/NAK。
  - **单个文件结束发送 EOT；若是批量传输，发送端按文件序继续发送下一个第0包**。
  - 批量结束通常用**空文件名的第0包或 EOT + 特定确认完成**（实现间细节略有差别）。

- 与 XMODEM 的主要区别
  - 第0包携带文件名与文件大小（支持多文件批量发送）。
  - 常用 1K 包（效率更高），通常默认 CRC 校验（使用 'C' 启动）。
  - 支持多个文件顺序传输，需对文件边界与空名终结做好处理。

- 关键细节
  - 第0包解析：**文件名以 NUL 结束，紧跟文件大小（ASCII），解析时注意空名表示结束**。
  - **文件尾填充需 strip（去除 0x1A/NUL 填充恢复原长度）**。
  - 接收端收到重复的第0包或数据包应按规范 ACK/NAK 处理以避免误写。
  - 不同实现在批量结束与 EOT 交互上有差异，需兼容常见实现（比如等待 ACK 后再次发送或额外确认）。
  - 对流式传输要做好粘包/半包、包头查找与缓冲管理。

# 实现
## 接收器
- 模块化接口：**定义了 XYMODEM_RECEIVER_INTERFACE_RRD 并通过函数指针（unpack/stop/start/strip_padding）解耦协议逻辑与外部 IO（send_data、save_data、get_time_ms）**。  
- 流解析与粘包处理：实现了流中搜索包头、校验包号/反码与校验和/CRC 的 unpack 逻辑，并提供 strip_padding 用于去除 0x1A/NUL 填充以还原真实文件长度。  
- 校验支持：使用 modem_common 提供的 moderm_calcu_sum 和 moderm_calcu_crc16，支持 checksum 与 CRC16（接收端通过发送启动字符选择）。  
- 状态管理：维护 retry_count、prev/next pack info（status_params），有 reset 函数统一重置重试计数。  
- 回调式数据保存：save_data 可选（为 NULL 时使用缓冲区直接读取），便于把接收逻辑嵌入不同存储后端（文件/内存/测试桩）。  
- 调试钩子：OPEN_XYMODEM_TEST 宏下提供 debug 函数，便于单元测试与本地验证。

## 发送器
- 接口与解耦：**XYMODEM_SENDER_INTERFACE_RRD 定义 send/start/stop/close_session，发送实际 IO 通过 send_data 回调注入，易移植到串口/套接字/测试环境**。  
- 包构建与长度策略：根据 config.length_type 与 moderm_get_data_length_size 选择 128/1K 包并填充 MODEM_NULL（0x1A），pack_and_send 负责构造 Header/blk/~blk/Data/校验。  
- 文件元信息支持：start_transfer 接口接受 file_name 与 file_size，支持 YMODEM 第0包（文件名+大小）语义。  
- 重传与控制码处理：实现发送控制码函数、重试计数与会话关闭（CAN/EOT/ACK/NAK 的处理点分布在 send_data 与 unpack_control_code）。  
- 可测试性：同样包含 OPEN_XYMODEM_SENDER_TEST 下的 debug 方法，便于在 test/sender 下运行。

## 共同点
- 公共常量与工具集中化（common/modem_common.{c,h}）：控制码、g_modem_soh/g_modem_start_transfer、CRC/sum、长度选择函数便于全局一致性。  
- 灵活性：**支持 XMODEM/YMODEM、128/1K、sum/CRC 三维配置；接口层完全通过回调与结构体配置。**  
- 易移植：**协议逻辑与底层传输（串口/文件）分离**，适合嵌入不同平台或做模拟单元测试。  

# 问题
## 1)
接收端只有在收到 EOT 时才能确认传输结束，才能判断上一包是否为末包并去掉填充字节。若提前写入最后一包，会把填充字节永久写入。

每个数据包都是固定长度（128/1024），不足部分用 0x1A/NUL 填充。若立即将收到的包写入文件，最后一包的填充无法在不支持截断或回写的场景下无损去除。因此需保留“上一包”直到确认有后续包或收到 EOT，再决定如何写入/裁剪。

**1. 针对 YMODEM 的优化**
- 若第0包包含文件大小：
  - 记录总大小并在写入时按大小裁剪最后一包（可选择直接写入所有包并在结尾截断，或按缓冲策略减少复杂度）。
  - 对单包文件仍需特殊处理（单包先缓冲，EOT 时裁剪并写入）。

**2. 替代方案**
- 立即写入 + ftruncate：若底层支持按已知文件长度截断（用第0包获取大小），可写入所有包，EOT 后截断。
- 随机写回：记录最后一包在文件位置，EOT 时定位重写有效部分（需要随机写能力）。